# -*- coding: utf-8 -*-
"""testcompgen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16mpa5GqPOvnutJ4rYXj4v3kJUjak0qno
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install PhenoGraph
!pip install palantir
!pip uninstall -y numpy
!pip install numpy
!pip uninstall -y numba
!pip install numba

#install in order,restart runtime.

import palantir

!pip install scanpy

import scanpy as sc

!pip install python-magic

import magic
import phenograph

import matplotlib.pyplot as plt

import pandas as pd

#file_path = '/content/drive/MyDrive/ComputationalGeonomics/marrow_sample_scseq_counts.h5ad'

!pip install scvelo

"""
print("Data shape:", adata.shape)

print("Cell barcodes (top 5):", adata.obs.head())

print("Gene names (top 5):", adata.var.head())

print("Unprocessed data matrix:\n", adata.X.toarray())

print("Cell metadata:", adata.obs)

print("Gene metadata:", adata.var)
"""

import scvelo as scv
import scanpy as sc
import phenograph
import os

!tar -xzf /content/drive/MyDrive/ComputationalGeonomics/compgen.tar.gz

# Replace this with the path to your folder
#input_folder = "/content/drive/MyDrive/ComputationalGeonomics/filtered_feature_bc_matrix"

# Read the input files
#adata = sc.read_10x_mtx(
#    input_folder,
#    var_names='gene_symbols',
#    cache=True
#)

#data_path = "/content/drive/MyDrive/ComputationalGeonomics/filtered_feature_bc_matrix"

#adata = sc.read_10x_mtx(data_path)

# Check if the dataset contains spliced and unspliced counts
#if "spliced" in adata.layers.keys() and "unspliced" in adata.layers.keys():
#    print("Dataset contains spliced and unspliced counts.")
#else:
#    print("Dataset does not contain spliced and unspliced counts.")

#import tarfile

#tar_path = '/content/drive/MyDrive/ComputationalGeonomics/GSE109774_Marrow.tar.gz'
#output_path = '/content/drive/MyDrive/ComputationalGeonomics/extracted_data'

#with tarfile.open(tar_path, 'r:gz') as tar:
#    tar.extractall(path=output_path)

#!tar -xzf /content/drive/MyDrive/ComputationalGeonomics/GSE109774_Marrow.tar.gz -C /content/drive/MyDrive/ComputationalGeonomics

"""Main Project Start."""

######################################################################################################################
######################################################################################################################
# MAIN PROJECT START
######################################################################################################################
#######################################################################################################################

!pip install scvelo --upgrade --quiet

import scvelo as scv
scv.logging.print_version()

adata = scv.datasets.pancreas()
adata

adata.X

adata.layers['spliced']
adata.layers['unspliced']

import pandas as pd
import numpy as np
!pip install magic-impute
import magic
import phenograph
import scvelo as scv

"""
dense_matrix = adata.X.toarray()
ms = dense_matrix.sum(axis=1)
ms = dense_matrix.sum(axis=1)
normalized_matrix = (dense_matrix / ms[:, np.newaxis]) * np.median(ms)
log_transformed_matrix = palantir.preprocess.log_transform(normalized_matrix)
df = pd.DataFrame(log_transformed_matrix, index=adata.obs_names, columns=adata.var_names)
dm_res = palantir.utils.run_diffusion_maps(df)

##########
magic_operator = magic.MAGIC()
magic_res = magic_operator.fit_transform(df)
_, _, clusters = phenograph.cluster(magic_res, k=10)  # You can change k to the desired number of clusters
# Add the cluster assignments to the AnnData object
adata.obs['palantir_clusters'] = pd.Series(clusters, index=adata.obs.index)

adata.layers["spliced"] = adata.layers["spliced"].astype("float64")
adata.layers["unspliced"] = adata.layers["unspliced"].astype("float64")"""

adata.layers["spliced"] = adata.layers["spliced"].astype("float64")
adata.layers["unspliced"] = adata.layers["unspliced"].astype("float64")

# Preprocessing
#scv.pp.filter_and_normalize(adata)
#scv.pp.moments(adata)

scv.tl.velocity(adata)

scv.tl.velocity_graph(adata)

scv.tl.velocity_embedding(adata, basis='umap')

dense_matrix = adata.X.toarray()
ms = dense_matrix.sum(axis=1)
normalized_matrix = (dense_matrix / ms[:, np.newaxis]) * np.median(ms)
log_transformed_matrix = palantir.preprocess.log_transform(normalized_matrix)
df = pd.DataFrame(log_transformed_matrix, index=adata.obs_names, columns=adata.var_names)
dm_res = palantir.utils.run_diffusion_maps(df)

magic_operator = magic.MAGIC()
magic_res = magic_operator.fit_transform(df)
_, _, clusters = phenograph.cluster(magic_res, k=30)  # Change k to the desired number of clusters
adata.obs['palantir_clusters'] = pd.Series(clusters, index=adata.obs.index)

velocity_clusters = adata.obs['palantir_clusters'].unique()
average_velocities = {}

for cluster in velocity_clusters:
    cluster_cells = adata[adata.obs['palantir_clusters'] == cluster]
    cluster_velocity = np.mean(cluster_cells.obsm['velocity_umap'], axis=0)
    average_velocities[cluster] = cluster_velocity

#matplotlib.rcParams['font.family'] = 'DejaVu Sans'

!pip install --upgrade matplotlib

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore", category=UserWarning)


# Scatter plot of UMAP with clusters
fig, ax = plt.subplots(figsize=(10, 10))
sns.scatterplot(x=adata.obsm['X_umap'][:, 0], y=adata.obsm['X_umap'][:, 1],
                hue=adata.obs['palantir_clusters'], palette='viridis', alpha=0.5, ax=ax)
ax.set_xlabel('UMAP1')
ax.set_ylabel('UMAP2')
ax.legend(title='Clusters')
plt.show()

import warnings
scv.pl.velocity_embedding_stream(adata, basis='umap', color='palantir_clusters')
warnings.filterwarnings("ignore", category=matplotlib.MatplotlibDeprecationWarning)

adata.obs['average_velocity_x'] = adata.obs['palantir_clusters'].map({k: v[0] for k, v in average_velocities.items()})
adata.obs['average_velocity_y'] = adata.obs['palantir_clusters'].map({k: v[1] for k, v in average_velocities.items()})

fig, ax = plt.subplots(figsize=(10, 10))
scatter = sns.scatterplot(x=adata.obsm['X_umap'][:, 0], y=adata.obsm['X_umap'][:, 1],
                          hue=adata.obs['palantir_clusters'], palette='viridis', alpha=0.5, ax=ax)

# Add quiver plot on top of the scatter plot to represent the average velocities
ax.quiver(adata.obsm['X_umap'][:, 0], adata.obsm['X_umap'][:, 1],
          adata.obs['average_velocity_x'], adata.obs['average_velocity_y'],
          color='k', scale_units='xy', scale=1, width=0.003, alpha=0.8)

ax.set_xlabel('UMAP1')
ax.set_ylabel('UMAP2')
ax.legend(title='Clusters')
plt.show()

plt.show()













############################################################
#################################################################


############################









